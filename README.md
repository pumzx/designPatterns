# designPatterns
设计模式-学习

一、策略模式

定义：策略模式定义了算法族，分别封装起来，让它们之间可以互相转换，此模式让算法的变化独立于使用算法的客户。

理解：对象拥有某种行为，对象和这种行为之间的关系就是has-a的关系。行为有很多种，互相之间可以替换，对象使用这个行为的时候没有感知。

OO原则：封装变化、多用组合，少用继承、针对接口编程，不针对实现编程。

举例：示例代码中的角色就是对象，各种使用武器的行为就是算法族。套用上面的定义就会更加明白。

二、观察者模式

定义：观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象的状态改变时，它的所有依赖者都会收到通知并自动更新。

理解：一个主题对应多个订阅者，主题状态变，需要通知所有订阅者update。两者之间松耦合。

OO原则：为交互对象之间的松耦合设计而努力。

举例：观察者模式是JDK中使用的最多的模式之一。

三、装饰者模式

定义：动态的将责任附加到对象上。想要扩展功能，装饰者提供了比继承更有弹性的替代方案。

理解：这是使用组合的典型代表，在保证装饰器类都是同一类型的前提下，通过使用组合来扩展自己的功能，并且扩展不会影响已有的代码。

OO原则：对扩展开发，对修改关闭。

举例：Java IO模型，里面大部分类都是装饰器

缺点：会产生很多小类，就像Java IO一样

四、工厂方法模式

定义：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

理解：工厂方法里主要就是创建了一个实例对象，让创建的过程不再依赖于使用这个对象的类，也就是将产品的实现从使用中解耦。

举例：一个类使用了另一个类的方法，另一个类具有不一样的实现方式，这个时候用工厂方法去创建另一个类，就能将一个类与另一个类解耦。

OO原则：要依赖抽象，不要依赖具体类（依赖倒置原则）（高层组件依赖底层组件）

如何遵循依赖倒置原则：变量不可以持有具体类的引用，不要让类派生自具体类，不要覆盖基类中以实现的方法（尽量做到这三点）

五、抽象工厂模式

定义：抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

理解：提供了一个interface，里面是一组相关的对象的创建方法，创建方法返回的是抽象类，不需要知道创建的对象具体是什么。由实现这个接口的类来实现创建方法，返回具体的类。

举例：创建一组相关类并且不关心具体创建了啥的时候，使用抽象工厂方法，在实现此接口者具体实现创建方法时，又可以用到工厂方法来创建。

六、单例模式

定义：单例模式确保一个类只有一个实例，并提供一个全局访问点

理解：私有化构造函数，并且提供一个public static的方法返回单例的实例对象

举例：线程池，驱动，缓存，注册表，日志对象等
